#!/usr/bin/env python
# /Users/seanking/Projects/tradewizard_4.1/src/llm_interpreter/run_single.py

import os
import sys
import logging
import json
from typing import Dict, Any, Optional
from datetime import datetime, timezone
from dotenv import load_dotenv
import asyncio
from supabase import create_client
from argparse import ArgumentParser
from modules.helpers import log_mcp_run, handle_mcp_result  # include patch helper

# Import the interpreter module and output formatter using absolute imports
from llm_interpreter.interpreter import process_assessment
from llm_interpreter.output_formatter import format_mcp_results

# Backwards compatibility stubs for missing imports
# process_single_assessment = process_assessment

async def run_single_assessment(record: dict) -> None:
    """Run WebsiteAnalysisModule and persist its output to mcp_runs."""
    from modules.website_analysis_module import WebsiteAnalysisModule

    module = WebsiteAnalysisModule()
    payload = await module.build_payload(record, [])
    mcp_output = await module.run(payload)

    # Log MCP run and apply its database patch
    log_mcp_run(
        mcp_name=module.name,
        mcp_version=module.version,
        payload=payload,
        result=mcp_output.get("result"),
        confidence=mcp_output.get("confidence"),
        llm_input_prompt=mcp_output.get("llm_input_prompt"),
        llm_raw_output=mcp_output.get("llm_raw_output"),
        error=mcp_output.get("error"),
        classification_id=record["id"]
    )
    # Apply the database patch generated by the MCP (e.g., insert products)
    handle_mcp_result(mcp_output)

    supabase = create_client(os.environ.get("NEXT_PUBLIC_SUPABASE_URL"), os.environ.get("SUPABASE_SERVICE_ROLE_KEY"))
    supabase.table("Assessments").update({
        "llm_ready": False,
        "status": "completed"
    }).eq("id", record["id"]).execute()

def main():
    # Expect assessment_id as first argument
    if len(sys.argv) < 2:
        logger.error("Assessment ID required. Usage: python run_single.py <assessment_id>")
        sys.exit(1)
    assessment_id = sys.argv[1]
    record = fetch_record(assessment_id)
    asyncio.run(run_single_assessment(record))

def fetch_record(assessment_id: str):
    supabase = create_client(os.environ.get("NEXT_PUBLIC_SUPABASE_URL"), os.environ.get("SUPABASE_SERVICE_ROLE_KEY"))
    response = supabase.table("Assessments").select("*").eq("id", assessment_id).execute()
    if not response.data:
        logger.error(f"Assessment with ID {assessment_id} not found.")
        return None
    return response.data[0]

def update_assessment_status(assessment_id: str, status: str):
    supabase_url = os.environ.get("NEXT_PUBLIC_SUPABASE_URL")
    supabase_key = os.environ.get("SUPABASE_SERVICE_ROLE_KEY")
    if supabase_url and supabase_key:
        supabase = create_client(supabase_url, supabase_key)
        supabase.table("Assessments").update({"status": status}).eq("id", assessment_id).execute()

def fetch_assessments_for_llm(*args, **kwargs):
    # Stub: not used in single-run
    return []

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Load environment variables
load_dotenv()

if __name__ == "__main__":
    main()
