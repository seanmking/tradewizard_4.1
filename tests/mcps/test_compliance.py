import pytest
import uuid
from typing import Dict, Any, List

# Assuming the mcps package is installable or PYTHONPATH is set
from modules.compliance import ComplianceMCP
from modules.base import MCPOutput

# --- Test Data ---

@pytest.fixture
def sample_product_id() -> str:
    return str(uuid.uuid4())

@pytest.fixture
def sample_classification() -> Dict[str, Any]:
    return {
        "id": str(uuid.uuid4()),
        "status": "compliance", # Status that enables ComplianceMCP
        "target_market": "EU",
        "category": "Electronics"
        # Add other fields if needed by build_payload
    }

@pytest.fixture
def sample_products(sample_product_id: str) -> List[Dict[str, Any]]:
    return [
        {
            "id": sample_product_id,
            "name": "Test Gadget X",
            "classification_id": "some_classification_id", # Match classification fixture if needed
            "description": "A sample electronic gadget.",
            "category": "Gadgets",
            "certifications": ["CE"], # Example existing cert
            "compliance_data": None # Start with no compliance data
            # Add other fields if needed by build_payload
        }
    ]

# --- Test Cases ---

def test_compliance_mcp_output_structure(sample_classification, sample_products):
    """Ensure ComplianceMCP.run() returns the expected MCPOutput structure."""
    mcp = ComplianceMCP()
    payload = mcp.build_payload(sample_classification, sample_products)
    output: MCPOutput = mcp.run(payload)

    # Check main output keys
    assert isinstance(output, dict)
    assert "result" in output
    assert "confidence" in output
    assert "_db_patch" in output
    assert "llm_input_prompt" in output # Even if None
    assert "llm_raw_output" in output   # Even if None
    assert "error" in output           # Even if None

    # Check result structure (based on current stub)
    result_data = output["result"]
    assert isinstance(result_data, dict)
    assert "required_certs" in result_data
    assert isinstance(result_data["required_certs"], list)
    assert "estimated_cost" in result_data
    assert isinstance(result_data["estimated_cost"], (int, float))
    assert "estimated_time" in result_data
    assert isinstance(result_data["estimated_time"], str)

    # Check confidence type
    assert isinstance(output["confidence"], (float, type(None)))

    # Check patch type
    assert isinstance(output["_db_patch"], (dict, type(None)))


def test_compliance_patch_shape(sample_classification, sample_products, sample_product_id):
    """Validate the structure of the _db_patch generated by ComplianceMCP."""
    mcp = ComplianceMCP()
    payload = mcp.build_payload(sample_classification, sample_products)
    output: MCPOutput = mcp.run(payload)

    db_patch = output.get("_db_patch")
    assert db_patch is not None, "_db_patch should be generated when product_id is present"
    assert isinstance(db_patch, dict)

    # Check table name
    assert "Products" in db_patch
    product_updates = db_patch["Products"]
    assert isinstance(product_updates, dict)

    # Check product ID key
    assert sample_product_id in product_updates
    product_patch_data = product_updates[sample_product_id]
    assert isinstance(product_patch_data, dict)

    # Check target column
    assert "compliance_data" in product_patch_data
    compliance_data_patch = product_patch_data["compliance_data"]
    assert isinstance(compliance_data_patch, dict)

    # Check keys within the compliance_data patch
    assert "required_certs" in compliance_data_patch
    assert "estimated_cost" in compliance_data_patch
    assert "estimated_time" in compliance_data_patch
    assert "mcp_confidence" in compliance_data_patch
    assert "mcp_version" in compliance_data_patch
    assert compliance_data_patch["mcp_version"] == mcp.version # Check version matches
